my_library <- "/lustre/scratch126/casm/team113da/users/jb62/projects/sparki/"
source(paste0(my_library, "src/main.R"))
source(paste0(my_library, "src/exceptions.R"))
source(paste0(my_library, "R/helper.R"))
source(paste0(my_library, "R/utilities.R"))
source(paste0(my_library, "R/plotting.R"))
source(paste0(my_library, "R/constants.R"))

###################
# Parse arguments #
###################

option_list <- list(
    optparse::make_option(
        c("--std-reports"),
        dest = "std_reports",
        action = "store",
        default = NA,
        type = "character",
        help = "Path to directory containing standard reports generated by Kraken2."
    ),
    optparse::make_option(
        c("--mpa-reports"),
        dest = "mpa_reports",
        action = "store",
        default = NA,
        type = "character",
        help = "Path to directory containing standard reports generated by Kraken2."
    ), 
    optparse::make_option(
        c("-r", "--reference"),
        dest = "refdb",
        action = "store",
        default = NA,
        type = "character",
        help = "Path to Kraken2 reference database."
    ),
    optparse::make_option(
        c("-m", "--metadata"),
        dest = "metadata",
        action = "store",
        default = NA,
        type = "character",
        help = "Path to metadata file [optional]."
    ),
    optparse::make_option(
        c("-c", "--columns"),
        dest = "columns",
        action = "store",
        default = NA,
        type = "character",
        help = "Comma-separated column names [if metadata file was provided]."
    ),
    optparse::make_option(
        c("-p", "--prefix"),
        dest = "prefix",
        action = "store",
        default = NA,
        type = "character",
        help = "Prefix of output files."
    ), 
    optparse::make_option(
        c("-o", "--outdir"),
        dest = "outdir",
        action = "store",
        default = NA,
        type = "character",
        help = "Path to output directory."
    ),
    optparse::make_option(
        c("-v", "--verbose"),
        dest = "verbose",
        action = "store_true",
        default = FALSE,
        type = "logical",
        help = "Verbosity level."
    ),
    optparse::make_option(
        c("--include-eukaryotes"),
        dest = "inc_eukaryotes",
        action = "store_true",
        default = FALSE,
        type = "logical",
        help = "Include eukaryotes in the final results table and plots."
    ),
    optparse::make_option(
        c("-s", "--include-sample-names"),
        dest = "inc_sample_names",
        action = "store_true",
        default = FALSE,
        type = "logical",
        help = "Include sample names in the plots."
    ),
    optparse::make_option(
        c("-d", "--domain"),
        dest = "domain",
        action = "store",
        default = NA,
        type = "character",
        help = "Domain of interest (e.g. Viruses)."
    )
)

####################
# Helper functions #
####################

read_prog_name_env_var <- function() {
    # Read the environment variable that contains the name of the program.
    prog_name <- Sys.getenv("PROG_NAME")
    if (is.null(prog_name)) {
        stop("Environment variable PROG_NAME not set.")
    }
    return(prog_name)
}

# Parse input arguments.
parse_options <- function(option_list, description = "") {
    # We need to fetch the program name from the environment variables.
    prog_name <- read_prog_name_env_var()

    # CLI arguments need some pre-processing before they can be parsed.
    raw_arguments <- commandArgs(trailingOnly = TRUE) # From the CLI
    raw_arguments <- raw_arguments[-1] # We only want to handle the arguments that come after 
                                       # the function name which is the first element.

    # Parse the arguments.
    parser <- optparse::OptionParser(
        option_list = option_list,
        add_help_option = TRUE,
        prog = prog_name,
        description = description
    )
    arguments <- optparse::parse_args(parser, args = raw_arguments)
    return(arguments)
}

# Compute PCA.
run_sparki_analysis <- function(arguments) {

    process_kraken2(
        std_reports_path = arguments$std_reports, 
        mpa_reports_path = arguments$mpa_reports,
        reference_path = arguments$refdb, 
        metadata_path = arguments$metadata,
        metadata_columns = arguments$columns,
        outdir_path = arguments$outdir,
        prefix = arguments$prefix,
        verbose = arguments$verbose,
        include_eukaryotes = arguments$inc_eukaryotes,
        include_sample_names = arguments$inc_sample_names,
        domain = arguments$domain
    )
}

###################
# CLI entrypoints #
###################

cli_run_sparki <- function() {

    description <- "Run SPARKI on a given set of Kraken2 results."

    parsed_arguments <- parse_options(option_list, description)
    run_sparki_analysis(parsed_arguments)
}

######################
# Run CLI Entrypoint #
######################

args <- commandArgs(trailingOnly = TRUE)[1]
func_name <- args[1]

# Empty list is to satisfy the function signature, the actual args are passed 
# via command line.
do.call(func_name, list()) 

